<style>
    p{
        text-indent:2em;
    }
</style>
[TOC]
# 一、算法的时间复杂度定义

　　在进行算法分析时，语句的总执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度。记作：T(n)=O(f(n))。<strong>它表示随问题n的增大,算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。</strong>其中，f(n)是问题规模n的某个函数。

　　这样用大写O()来体现算法时间复杂度的记法，我们称之为<font color="red"><b>大O记法</b></font>。

# 二、推导大O阶方法

1、用常数1取代运行时间中的所有加法常数。

2、在修改后的运行次数函数中，只保留最高阶项。

3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。

# 三、示例

## 1、常数阶

```c
int sum = 0, n = 100;   //执行一次
sum = (1 + n) * n / 2;  //执行一次
printf("%d",sum);       //执行一次
```
这个算法的运行次数函数是f(n) = 3。把常数项3改为1.在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为<b>O(1)</b>。

<b>单纯的分支结构(不包含在循环结构中)，其时间复杂度也是O(1)。</b>

## 2、线性阶

```c
int i;
for(i = 0; i < n; i++){
    /*时间复杂度为O（1）的程序步骤序列*/
}
```

时间复杂度为O(n)

## 3、对数阶

```c
int count = 1;
while(count < n){
    count = count * 2;
    /* 时间复杂度为O(1)的程序步骤序列*/
}
```

由于每次count乘以2后，距离n更近了。也就是说，有多少个2相乘后大于n，则就会退出循环。由2^x=n 得到x=logn。所以这个循环的时间复杂度为O(logn)。

## 4、平方阶

```c
int i, j;
for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
        /*时间复杂度为O(1)的程序步骤序列*/
    }
}
```
循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。
```c
int i, j;
for(i = 0; i < n; i++){
    for(j = i; j < n; j++){
        /*时间复杂度为O(1)的程序步骤序列*/
    }
}
```
由于当i=0时，内循环执行了n次，当i = 1时，执行了n-1次，……当i=n-1时，执行了1次。所以总的执行次数为:
<div align=center><img ; src="https://img-blog.csdn.net/20170327144317062"></div>

用我们推导大O阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最高阶项，因此保留时(n^2)/2;第三条，去除这个项相乘的常数，也就是去除1/2，最终这段代码的时间复杂度为O(n\^2)。

## 5、立方阶
```c
int i, j;
for(i = 1; i < n; i++)
    for(j = 1; j < n; j++)
        for(k = 1; k < n; k++){
             /*时间复杂度为O(1)的程序步骤序列*/
        }
```
 这里循环了(1\^2+2\^2+3^2+……+n\^2) = n(n+1)(2n+1)/6次，按照上述大O阶推导方法，时间复杂度为O(n\^3)。

 # 常见的时间复杂度
 
 <div align=center><img src="https://img-blog.csdn.net/20170327162904721"></div>

 常用的时间复杂度所耗费的时间从小到大依次为:
<div align=center><img src="https://img-blog.csdn.net/20170327162956884"></div>

# 四、最坏情况与平均情况
我们查找一个有n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。

<b>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。 在应用中，这是一种最重要的需求， 通常， 除非特别指定， 我们提到的运行时间都是最坏情况的运行时间。</b>

而平均运行时间也就是从概率的角度看， 这个数字在每一个位置的可能性是相同的，所以平均的查找时间为n/2次后发现这个目标元素。<b>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。</b>也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。一般在没有特殊说明的情况下，都是指<b>最坏时间复杂度</b>。

# 五、常用算法的时间复杂度和空间复杂度

<div align=center><img src="https://img-blog.csdn.net/20170327164357916"></div>


<div align=right style="font-size:20px;">xybh&nbsp&nbsp&nbsp&nbsp</div>
<div align=right style="font-size:20px;">2019/7/10</div>